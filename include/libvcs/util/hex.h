#pragma once

#include <ranges>
#include <span>
#include <string>

namespace util {
namespace detail {

/// Lowercase hexadecimal digits.
inline constexpr char kHexDigits[16] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

// clang-format off
inline constexpr uint8_t kUnhexTable[256]= {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0,    1,    2,    3,    4,    5,    6,    7,
     8,    9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff,   10,   11,   12,   13,   14,   15, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff,   10,   11,   12,   13,   14,   15, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
// clang-format on

} // namespace detail

/**
 * Converts byte string to hexadecimal representation.
 *
 * @returns number of characters written to the output buffer.
 */
template <typename T, std::size_t Extent = std::dynamic_extent>
constexpr size_t BytesToHex(const std::span<T, Extent> data, char* _Nonnull buf) noexcept {
  for (auto i : std::views::iota(0u, data.size())) {
    buf[2 * i] = detail::kHexDigits[(static_cast<uint8_t>(data[i]) >> 4) & 0x0f];
    buf[2 * i + 1] = detail::kHexDigits[static_cast<uint8_t>(data[i]) & 0x0f];
  }
  return 2 * data.size();
}

/**
 * Creates hexadecimal representation of a byte string.
 */
template <typename T, std::size_t Extent = std::dynamic_extent>
constexpr std::string BytesToHex(const std::span<T, Extent> data) {
  std::string hex;

  hex.resize_and_overwrite(2 * data.size(), [&](char* buf, std::size_t) { return BytesToHex(data, buf); });

  return hex;
}

/**
 * Checks if an ASCII character is a hex digit.
 *
 * @param ch character to check.
 */
constexpr bool IsHex(const unsigned char ch) noexcept {
  return detail::kUnhexTable[ch] != 0xff;
}

/**
 * Returns byte value for corresponding hex character.
 *
 * @param ch character to convert.
 */
constexpr uint8_t HexToByte(const unsigned char ch) noexcept {
  return detail::kUnhexTable[ch];
}

} // namespace util
